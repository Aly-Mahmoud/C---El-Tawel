<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<Constructor>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    ->  it's a (special function = special method)
    ->  you can create it, if you did not compiler will and will give the constructor function the same name as the <<class>
    ->  you do not call it, it calls itself automatically when creating an (instance = object)  ????after constructing and heap memory reservation????
    ->  has no return type
    ->  can be overloaded

    <<<<<<<<<<<<<<<<<<<<<<<Types of Constructor>>>>>>>>>>>>>>>>>>>>>>>
        -> defult constructor (Zero Argument Constructor)
            -> A constructor that does not take from me any parameters
            -> Called once when creating an instance from a class

        -> Parameterized Constructor (Overloaded Constructor)
            -> many functions with the same name however they have different signatures-> anything after the name of the function like (Parameters, attributes)
            -> this concept of similar name different signatures is called name mangling -> handkled by compiler in different ways according to your compiler used
            -> if you made a Parameterized Constructor it prevents the compiler to create the defult constructor, so if you need it you must create it on your own

        -> Copy Constructor

        -> Delegating Constructor
            -> iam lazy : if you call me, i will call another constructor to do my job
            -> it's a good practise, you make defult values for objects even if you just called in 

        -> Move Constructor -> move semantics(C++)
    /*--------------------------------------------------------------*/

    <<<<<<<<<<<<<<<<<<<<Constructor Initilization list>>>>>>>>>>>>>>>>>>>>
        int x = 5;  -> C like
        int x (5);  -> Constructor like
        int x {5};  -> uniform Initilization -> check between the two types of data (expected to send) & (what was actually send) ensure no casting happens
            int x = {5.3} -> error -> no casting will happen
        
        int x; // reseve empty space in memory
        x = 5; // assignation

        int x=5; //reservation & assignation in the same line

        can i do the same in the class? YES
        Person () : name {"None"}, ID{"None"}
        {
            implementation
        }

        if not in order it will allocate and then initialize
        
        can i do the same in creating an object?
    /*--------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------*/

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<Destructor>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    ->  it's a (special function = special method)
    ->  you can create it, if you did not compiler will and will give the constructor function the same name as the class but preceded with telda <~class>
    ->  you do not call it, it calls itself automatically when destroying an (instance = object)  ????after destructing and heap memory reservation????
    -> destruction will happen when the program gets out of the scope of the object whether it was <<}>> or <<return 0>>;
    ->  has no return type
    -> can not be overload

/*----------------------------------------------------------------------------------------------*/

